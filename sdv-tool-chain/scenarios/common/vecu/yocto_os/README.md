*Copyright (C) Microsoft Corporation*

# sdv-toolchain-yocto-os

A sample to build a custom-based Linux distribution using Yocto to run on an Azure VM.

## Portability

This sample can be ported to its own repository. To do that, please follow the steps below:

1. Create a new repository.
1. Copy the contents of this folder `doc/samples/sdv-toolchain-yocto-os` to the new repository.
1. Create `./github/workflows` directory in the new repository.
1. Copy the `./github/workflows/sdv_toolchain_yocto_os_build.yml` file to the new repository.
1. Remove all sections that are commented with "# Remove this if Yocto is in its own repo" from `./github/workflows/sdv_toolchain_yocto_os_build.yml`.

## Yocto Files

The `meta-machine-azure` directory contains the Yocto layer defintion for building a sample Linux distribution to run on an Azure VM. The file structure in this directory follows the best practices as specified in [Understand and Creating Layers](https://docs.yoctoproject.org/dev/dev-manual/layers.html).

Under the `conf` directory, the `layer.conf` file specifies our layer's configuration. The `azure-vm-arm64.conf` file is the machine configuration file to allow you to specify settings such as defining which Linux Kernel version to use.
For more information on the machine configuration file, please see [Adding a New Machine](https://docs.yoctoproject.org/dev/dev-manual/new-machine.html).

The `recipes-azure` directory consists of additional recipes that we wish to bake into our sample Linux distribution in order for the distribution to be compatible with Azure. Other recipes that are needed are defined in the other repositories that we clone in the [`build_arm64.sh`](./tools/build_arm64.sh) script.

The `recipes-azure/recipes-extended/symphony-agent` directory contains a Yocto recipe detailing the steps needed to set up and launch a [Symphony Agent](https://github.com/eclipse-symphony/symphony/blob/main/docs/symphony-book/agent/_overview.md) as a systemd service.

### Prerequisites
- A self-hosted Github runner that runs on an Azure VM.
  - Please see the recommendations on Virtual Machine SKUs in [Test results for building custom linux image based on Yocto on azure](doc/github_custom_runner_vm_sizes.md).
  - Please see the [Access](#access) section for the required permissions for the Service Principal of your Azure VM.
- An Azure Storage Account resource deployed.
  - A Storage Blob Container created within your Azure Storage Account. The artifact generated by the [Build Yocto](../../../../.github/workflows/sdv_toolchain_yocto_os_build.yml) workflow is a Yocto VHD, which will be saved to your Blob Container by the workflow too.
    - A `symphony-agent` ARM64 binary uploaded to your Storage Blob Container. Reference [Use Symphony as a binary](https://github.com/eclipse-symphony/symphony/blob/main/docs/symphony-book/get-started/quick_start_binary.md) for the build dependencies and navigating to the build directory. Run the following to compile an agent for the vECU:

      ```bash
      env GOOS=linux GOARCH=arm64 go build -o symphony-agent
      ```

    The `Build Yocto` workflow will pull your `symphony-agent` binary from your Storage Account Blob Container, and place the binary into the [symphony-agent](../yocto_os/meta-machine-azure/meta-azure/recipes-azure/recipes-extended/symphony-agent/) recipe.
- An Azure Compute Gallery resource deployed.
  - An Image Definition created within your Compute Gallery. This is an entry point for the workflow to create an Image Version that points to the Yocto VHD in your Blob Container. The Image Version is used to create a VM with our sample Linux distribution.
- A [Github Personal Access Token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) to deploy the `Build Yocto` workflow.

### Deployment (CI/CD)

```shell
curl \
  -X POST \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer {GITHUB_PAT}" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/<GITHUB_ORG>/sdv-toolchain-yocto-os/actions/workflows/build_yocto.yml/dispatches \
  -d '{"ref": "main", "inputs": {"resource_group_name": "<RESOURCE_GROUP>", "subscription_id": "<SUBSCRIPTION_ID>", storage_account_name": "<STORAGE_ACCOUNT>", "blob_container_name": "<STORAGE_BLOB_CONTAINER>", "blob_image_name": "<YOCTO_IMAGE>.vhd", "compute_gallery_name": "<COMPUTE_GALLERY>", "image_definition_name": "<IMAGE_DEFINITION>", "image_version_number": "<IMAGE_VERSION_NUMBER>"}}'
```

Please set the placeholder values `<PLACEHOLDER>` with your own values.

## Access

Enable a system-assigned managed identity for your Azure VM where your self-hosted Github runner is running on.

Please configure your system-assigned managed identity to have the following roles:
- Reader role access to your resouce group.
- Storage Blob Data Contributor role access to your resource group.
- Contributor role access to your compute gallery.

## Toolchain Customizations

When dispatching a GitHub workflow, the API response does not provide any identifying information for the workflow run (such as a UID or correlation id). This makes it impossible to programmatically dispatch a workflow and then directly poll for the status of the workflow run. To work around this issue, the Symphony campaign that dispatches the workflow depends on the workflow run having a unique name `run_name` that it can be identified by. To meet this requirement, `sdv_toolchain_yocto_os_build.yml` contains the following:

1. In the `inputs` section, an optional field called `run_name`:
    ```
    run_name:
        description: 'Identifying name for this workflow run'
        required: false
        default: '<NAME OF YOUR WORKFLOW>'
    ```
1. A [run-name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#run-name) value for the workflow:
    ```
    run-name: ${{ github.event.inputs.run_name }}
    ```
